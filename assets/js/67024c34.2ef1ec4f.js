"use strict";(self.webpackChunkTHM_Notes=self.webpackChunkTHM_Notes||[]).push([[9722],{4315:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>i,default:()=>l,frontMatter:()=>t,metadata:()=>o,toc:()=>h});var c=n(4848),r=n(8453);const t={},i="Charsets",o={id:"Others/Regular expressions",title:"Regular expressions",description:"Regular expressions (or Regex) are patterns of text that you define to search documents and match exactly what you're looking for.",source:"@site/docs/Others/Regular expressions.md",sourceDirName:"Others",slug:"/Others/Regular expressions",permalink:"/docs/Others/Regular expressions",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"THMSidebar",previous:{title:"John The Ripper",permalink:"/docs/Others/John The Ripper"},next:{title:"Upload Vulnerabilities",permalink:"/docs/Others/Upload Vulnerabilities"}},a={},h=[];function d(e){const s={a:"a",br:"br",code:"code",h1:"h1",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(s.p,{children:"#Skills"}),"\n",(0,c.jsx)(s.p,{children:"Regular expressions (or Regex) are patterns of text that you define to search documents and match exactly what you're looking for."}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["use ",(0,c.jsx)(s.code,{children:"egrep <pattern> <file>"})]}),"\n",(0,c.jsx)(s.li,{children:(0,c.jsx)(s.a,{href:"https://regexr.com/",children:"Regexr"})}),"\n"]}),"\n",(0,c.jsx)(s.h1,{id:"charsets",children:"Charsets"}),"\n",(0,c.jsxs)(s.p,{children:["A charset is defined by enclosing in ",(0,c.jsx)(s.code,{children:"["})," square brackets ",(0,c.jsx)(s.code,{children:"]"})," the character(s), or range of characters that you want to match."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"[abc]"})," will match ",(0,c.jsx)(s.code,{children:"a"}),", ",(0,c.jsx)(s.code,{children:"b"}),", and ",(0,c.jsx)(s.code,{children:"c"})," (every occurrence of each letter)"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"[abc]zz"})," will match ",(0,c.jsx)(s.code,{children:"azz"}),", ",(0,c.jsx)(s.code,{children:"bzz"}),", and ",(0,c.jsx)(s.code,{children:"czz"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["You can also use a ",(0,c.jsx)(s.code,{children:"-"})," dash to define ranges:",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"[a-c]zz"})," is the same as above."]}),"\n",(0,c.jsxs)(s.p,{children:["And then you can combine ranges together:",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"[a-cx-z]zz"})," will match ",(0,c.jsx)(s.code,{children:"azz"}),", ",(0,c.jsx)(s.code,{children:"bzz"}),", ",(0,c.jsx)(s.code,{children:"czz"}),", ",(0,c.jsx)(s.code,{children:"xzz"}),", ",(0,c.jsx)(s.code,{children:"yzz"}),", and ",(0,c.jsx)(s.code,{children:"zzz"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["Most notably, this can be used to match any alphabetical character:",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"[a-zA-Z]"})," will match any ",(0,c.jsx)(s.strong,{children:"single"})," letter (lowercase or uppercase)."]}),"\n",(0,c.jsxs)(s.p,{children:["You can use numbers too:",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"file[1-3]"})," will match ",(0,c.jsx)(s.code,{children:"file1"}),", ",(0,c.jsx)(s.code,{children:"file2"}),", and ",(0,c.jsx)(s.code,{children:"file3"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["Then, there is a way to ",(0,c.jsx)(s.strong,{children:"exclude"})," characters from a charset with the ",(0,c.jsx)(s.code,{children:"^"})," hat symbol, and include everything else.",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"[^k]ing"})," will match ",(0,c.jsx)(s.code,{children:"ring"}),", ",(0,c.jsx)(s.code,{children:"sing"}),", ",(0,c.jsx)(s.code,{children:"$ing"}),", but not ",(0,c.jsx)(s.code,{children:"king"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["Of course, you can exclude charsets, not just single characters.",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"[^a-c]at"})," will match ",(0,c.jsx)(s.code,{children:"fat"})," and ",(0,c.jsx)(s.code,{children:"hat"}),", but not ",(0,c.jsx)(s.code,{children:"bat"})," or ",(0,c.jsx)(s.code,{children:"cat"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Note 1"}),": Don't confuse strings with charsets. The charset ",(0,c.jsx)(s.code,{children:"[abc]"})," will match the string ",(0,c.jsx)(s.code,{children:"abc"}),", but also ",(0,c.jsx)(s.code,{children:"cba"})," and ",(0,c.jsx)(s.code,{children:"ca"}),". It doesn't match the string, but rather ",(0,c.jsx)(s.strong,{children:"every occurrence"})," of the specified characters in that string."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Note 2"}),": When specifying charsets, you should type the letters in the same order they appear in the questions, to avoid typing something correct that is not the right answer."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Note 3: Answering some of these questions is going to be tricky."})," Often times there are many different patterns that match specific strings. That means (as stated in the previous note) that you may find a proper solution that isn't the right answer for this room (because there can only be one). The right answer is typically the most efficient regex for that question. Efficient in this context means 2 things:",(0,c.jsx)(s.br,{}),"\n","\xa0\xa0\xa0 ",(0,c.jsx)(s.strong,{children:"1. Be specific."})," Here's an example: you could match any character from a to c using the ",(0,c.jsx)(s.code,{children:"[a-z]"})," charset. But if the question only requires you to match characters from ",(0,c.jsx)(s.code,{children:"a"})," to ",(0,c.jsx)(s.code,{children:"c"}),", you should use the ",(0,c.jsx)(s.code,{children:"[a-c]"})," charset, not ",(0,c.jsx)(s.code,{children:"[a-z]"}),".",(0,c.jsx)(s.br,{}),"\n","\xa0\xa0\xa0 ",(0,c.jsx)(s.strong,{children:"2. Don't be too specific."})," In contrast to the previous example, if a question requires you to match ",(0,c.jsx)(s.code,{children:"a"}),", ",(0,c.jsx)(s.code,{children:"c"}),", ",(0,c.jsx)(s.code,{children:"f"}),", ",(0,c.jsx)(s.code,{children:"r"}),", ",(0,c.jsx)(s.code,{children:"s"}),", ",(0,c.jsx)(s.code,{children:"z"}),", at that point, the expression that matches those specific characters would get longer and more complicated. So, it would make more sense to use ",(0,c.jsx)(s.code,{children:"[a-z]"}),", because it is short and simple."]}),"\n",(0,c.jsx)(s.h1,{id:"wildcards-and-optional-characters",children:"Wildcards and optional characters"}),"\n",(0,c.jsxs)(s.p,{children:["The wildcard that is used to match any single character (except the line break) is the ",(0,c.jsx)(s.code,{children:"."})," dot. That means that ",(0,c.jsx)(s.code,{children:"a.c"})," will match ",(0,c.jsx)(s.code,{children:"aac"}),", ",(0,c.jsx)(s.code,{children:"abc"}),", ",(0,c.jsx)(s.code,{children:"a0c"}),", ",(0,c.jsx)(s.code,{children:"a!c"}),", and so on."]}),"\n",(0,c.jsxs)(s.p,{children:["Also, you can set a character as optional in your pattern using the ",(0,c.jsx)(s.code,{children:"?"})," question mark. That means that ",(0,c.jsx)(s.code,{children:"abc?"})," will match ",(0,c.jsx)(s.code,{children:"ab"})," and ",(0,c.jsx)(s.code,{children:"abc"}),", since the ",(0,c.jsx)(s.code,{children:"c"})," is optional."]}),"\n",(0,c.jsxs)(s.p,{children:["Note: If you want to search for ",(0,c.jsx)(s.code,{children:"."})," a literal dot, you have to ",(0,c.jsx)(s.strong,{children:"escape it"})," with a ",(0,c.jsx)(s.code,{children:"\\"})," reverse slash. That means that ",(0,c.jsx)(s.code,{children:"a.c"})," will match ",(0,c.jsx)(s.code,{children:"a.c"}),", but also ",(0,c.jsx)(s.code,{children:"abc"}),", ",(0,c.jsx)(s.code,{children:"a@c"}),", and so on. But ",(0,c.jsx)(s.code,{children:"a\\.c"})," will match ",(0,c.jsx)(s.strong,{children:"just"})," ",(0,c.jsx)(s.code,{children:"a.c"}),"."]}),"\n",(0,c.jsx)(s.h1,{id:"metacharacters-and-repetitions",children:"Metacharacters and repetitions"}),"\n",(0,c.jsxs)(s.p,{children:["There are easier ways to match bigger charsets.\n",(0,c.jsx)(s.code,{children:"\\d"})," matches a digit, like ",(0,c.jsx)(s.code,{children:"9"}),(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"\\D"})," matches a non-digit, like ",(0,c.jsx)(s.code,{children:"A"})," or ",(0,c.jsx)(s.code,{children:"@"}),(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"\\w"})," matches an alphanumeric character, like ",(0,c.jsx)(s.code,{children:"a"})," or ",(0,c.jsx)(s.code,{children:"3"}),"\n",(0,c.jsx)(s.code,{children:"\\W"})," matches a non-alphanumeric character, like ",(0,c.jsx)(s.code,{children:"!"})," or ",(0,c.jsx)(s.code,{children:"#"}),(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"\\s"})," matches a whitespace character (spaces, tabs, and line breaks)",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"\\S"})," matches everything else (alphanumeric characters and symbols)\nNote: Underscores ",(0,c.jsx)(s.code,{children:"_"})," are included in the ",(0,c.jsx)(s.code,{children:"\\w"})," metacharacter and not in ",(0,c.jsx)(s.code,{children:"\\W"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["Often we want a pattern that matches many characters of a single type in a row, and we can do that with repetitions. For example, ",(0,c.jsx)(s.code,{children:"{2}"})," is used to match the preceding character (or metacharacter, or charset) two times in a row. That means that ",(0,c.jsx)(s.code,{children:"z{2}"})," will match exactly ",(0,c.jsx)(s.code,{children:"zz"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"{12}"})," - ",(0,c.jsx)(s.strong,{children:"exactly 12"})," times.",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"{1,5}"})," - ",(0,c.jsx)(s.strong,{children:"1 to 5"})," times.",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"{2,}"})," - ",(0,c.jsx)(s.strong,{children:"2 or more"})," times.",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"*"})," - ",(0,c.jsx)(s.strong,{children:"0 or more"})," times.",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"+"})," - ",(0,c.jsx)(s.strong,{children:"1 or more"})," times."]}),"\n",(0,c.jsx)(s.h1,{id:"starts-with-ends-with-groups-and-either-or",children:"Starts with/ ends with, groups, and either/ or"}),"\n",(0,c.jsxs)(s.p,{children:["Sometimes it's very useful to specify that we want to search by a certain pattern ",(0,c.jsx)(s.strong,{children:"in the beginning or the end of a line"}),". We do that with these characters:",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"^"})," - starts with",(0,c.jsx)(s.br,{}),"\n",(0,c.jsx)(s.code,{children:"$"})," - ends with"]}),"\n",(0,c.jsxs)(s.p,{children:["So for example, if you want to search for a line that ",(0,c.jsx)(s.strong,{children:"starts with"})," ",(0,c.jsx)(s.code,{children:"abc"}),", you can use ",(0,c.jsx)(s.code,{children:"^abc"}),".",(0,c.jsx)(s.br,{}),"\n","If you want to search for a line that ",(0,c.jsx)(s.strong,{children:"ends with"})," ",(0,c.jsx)(s.code,{children:"xyz"}),", you can use ",(0,c.jsx)(s.code,{children:"xyz$"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["Note: The ",(0,c.jsx)(s.code,{children:"^"})," hat symbol is used to exclude a charset when enclosed in ",(0,c.jsx)(s.code,{children:"["}),"square brackets",(0,c.jsx)(s.code,{children:"]"}),", but when it is not, it is used to specify the beginning of a word."]}),"\n",(0,c.jsxs)(s.p,{children:["You can also define groups by enclosing a pattern in ",(0,c.jsx)(s.code,{children:"("}),"parentheses",(0,c.jsx)(s.code,{children:")"}),". This function can be used for many ways that are not in the scope of this tutorial. We will use it to define an ",(0,c.jsx)(s.strong,{children:"either/ or"}),' pattern, and also to repeat patterns. To say "or" in Regex, we use the ',(0,c.jsx)(s.code,{children:"|"})," pipe."]}),"\n",(0,c.jsxs)(s.p,{children:['For an "either/or" pattern example, the pattern ',(0,c.jsx)(s.code,{children:"during the (day|night)"})," will match both of these sentences: ",(0,c.jsx)(s.code,{children:"during the day"})," and ",(0,c.jsx)(s.code,{children:"during the night"}),".",(0,c.jsx)(s.br,{}),"\n","For a repetition example, the pattern ",(0,c.jsx)(s.code,{children:"(no){5}"})," will match the sentence ",(0,c.jsx)(s.code,{children:"nonononono"}),"."]})]})}function l(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,c.jsx)(s,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>o});var c=n(6540);const r={},t=c.createContext(r);function i(e){const s=c.useContext(t);return c.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),c.createElement(t.Provider,{value:s},e.children)}}}]);